uztwc <- 0  # Upper zone tension water storage
uzfwc <- 0  # Upper zone free water storage
lztwc <- 5  # Lower zone tension water storage
lzfsc <- 5  # Lower zone supplementary free water storage
lzfpc <- 5  # Upper zone primary free water storage
adimc <- 0  # Additional impervious area storage
inistates <- c(uztwc, uzfwc, lztwc, lzfsc, lzfpc, adimc)
# Include states for snow17 if snow module is 'on'
if (flag_SNOW17 == 1) {
W_i     <- 0  # Accumulated water equivalent of the ice portion of the snow cover (mm)
ATI     <- 0  # Antecedent Temperature Index, deg C
W_q     <- 0  # Liquid water held by the snow (mm)
Deficit <- 0  # Heat Deficit, also known as NEGHS, Negative Heat Storage
inistates <- c(inistates, W_i, ATI, W_q, Deficit)
}
# Base Time of Unit Hydrographs of HRU and River in Routing model.
# (Necessary to be changed only for a VERY LARGE watershed)
KE      <-  12  # Base time for HRU UH (day)
UH_DAY  <-  96  # Base time for river routing UH (day)
# Run Distributed System Modeling version of SAC_SMA for each HRU
sim_date <- seq.Date(str_date, end_date, by = "day")
sim_per  <- length(sim_date)      # Simulation period
num_hru  <- nrow(gridinfo)        # Total number of HRUs
tot_area <- sum(grid_area)        # Total watershed area
#TOTFLOW <- matrix(0, nrow = sim_per, ncol = num_hru)
#Run through each HRU, simulate streamflow
FLOW <- vector(mode = "numeric", length = sim_per)
for (n in 1:num_hru) {
# Read-in data for current HRU
hru_lat <- formatC(grid_lat[n], format = 'f', flag='0', digits = 5)
hru_lon <- formatC(grid_lon[n], format = 'f', flag='0', digits = 5)
griddata  <- read.table(paste0(hru_filedir,hru_lat, "_", hru_lon))
# Find starting and ending indices based on the specified dates
grid_date <- griddata %>% as_data_frame() %>%
mutate(Date = paste(V1,V2,V3, sep ="/") %>% as.Date()) %>% pull(Date)
sind <- which(str_date == grid_date)
eind <- which(end_date == grid_date)
# FLOW SIMULATION USING SAC-SMA MODEL --------------------------------------
#Set relevant precipitation and temperature time-series
hru_prcp    <- griddata[sind:eind,4]
hru_temp    <- griddata[sind:eind,5]
hru_area    <- grid_area[n]
hru_elev    <- grid_elev[n]
hru_flowlen <- grid_flowlen[n]
hru_par     <- grid_par[n,] %>% as.numeric()
#Simulate streamflow for each HRU
hru_simflow <- sac_sma(S_Date = str_date, E_Date = end_date,
Prcp = hru_prcp, Tavg = hru_temp, Basin_Lat = hru_lat,
Basin_Elev = hru_elev, Par = hru_par, IniState = inistates,
flag_snowmodule = 0)
hru_simflow <- hru_simflow * hru_area / tot_area
# # CHANNEL ROUTING FROM LOHMANN MODEL ---------------------------------------
pars_rout <- hru_par[28:length(hru_par)] # Routing model parameters
UH_river  <- route_lohamann(pars = pars_rout, flowlen = hru_flowlen, KE = KE, UH_DAY = UH_DAY)
# MAKE CONVOLUTION FOR BASIN OUTLET STREAMFLOW -----------------------------
for(i in 1:sim_per) {
#Loop through "base time periods"
for(j in 1:(KE+UH_DAY-1)) {
if((i-j+1) >= 1) {
FLOW[i] <- FLOW[i] + UH_river[j] * hru_simflow[i-j+1]
}
} #close the loop for each hru
return(FLOW)
}
results <- sac_sma_dsm(str_date = as.Date("1995/10/1"),
end_date = as.Date("2014/09/30"),
grid_lat = gridinfo[[1]],
grid_lon = gridinfo[[2]],
grid_area = gridinfo[[3]],
grid_elev = gridinfo[[4]],
grid_flowlen = gridinfo[[5]],
grid_par  = calib_par)
#})
results
tail(results)
sum(FLOW)
# Additional impervious zone states
adimc_tot <- empty_vec   # State of additional impervious area storages [mm]
# MODEL OUPUT ARRAY INITIALIZATION
simflow  <- empty_vec  # Simulated Streamflow
tet_tot  <- empty_vec  # Simulated Actual Evapotranspiration
base_tot <- empty_vec  # Simulated Base Flow
surf_tot <- empty_vec  # Simulated Surface&Subsurface water flow
SWE_tot  <- empty_vec  # Simulated Snow Water Equivalent (SWE)
#CALCULATE PET (HAMON EQUATION) ----------------------------------------------
sim_date <- seq.Date(S_Date, E_Date, by = "day")
sim_date_mat  <- data_frame(Year=year(sim_date), Month=month(sim_date),
Day = day(sim_date), doy=yday(sim_date))
pet <- petHamon2(doy=sim_date_mat$doy,
coeff = coeff, basin_lat = as.numeric(Basin_Lat), Tavg=Tavg)
yday("1919/12/31")
library(lubridate)
yday("1919/12/31")
yday("1920/12/31")
?seq.Date
test <- ("1920/12/31")
as.Date(paste0(year(test),"/12/31"))
end_doy <- yday(as.Date(paste0(year(test),"/12/31")))
end_doy
end_doy <- yday(as.Date(paste0(year(test),"/12/31"))) - 365
end_doy
yday(as.Date(paste0(year(test),"/12/31")))
#SNOW MODULE
snow17 <- function(pars, prcp, temp, elev, states_input, TIME) {
#State parameters
W_i     <- states_input[1]; ATI <- states_input[2]
W_q     <- states_input[3]; Deficit <- states_input[4]
#Other parameters
SCF    <- pars[1]; PXTEMP <- pars[2]; MFMAX <- pars[3]; MFMIN <- pars[4]
UADJ   <- pars[5]; MBASE  <- pars[6]; TIPM  <- pars[7]; PLWHC  <- pars[8]
NMF    <- pars[9]; DAYGM  <- pars[10]
dtt <- 24  # time interval of temperature data
dtp <- 24  # time interval of prcipitation data
Ta <- temp  # Air temperature at this time step [deg C]
Pr <- prcp  # Precipitation at this time step [mm]
# FORM OF PRECIPITATION
if (Ta <= PXTEMP) {
# Air temperature is cold enough for snow to occur
SNOW <- Pr
RAIN <- 0
} else {
# Air temperature is warm enough for rain
SNOW <- 0
RAIN <- Pr
}
# ACCUMULATION OF THE SNOW COVER
Pn  <- SNOW * SCF  # Water equivalent of new snowfall [mm]
W_i <- W_i + Pn    # Water equivalent of the ice portion of the snow cover [mm]
E   <- 0           # Excess liquid water in the snow cover
# ENERGY EXCHANGE AT SNOW/AIR SURFACE DURING NON-MELT PERIODS
# Seasonal variation in the non-rain melt factor
DAYN <- TIME[2]
end_doy <- yday(as.Date(paste0(year(test),"/12/31"))) - 365
N_Mar21 <- DAYN - (80 + end_doy)
Sv <- (0.5*sin((N_Mar21 * 2 * pi)/days)) + 0.5        # Seasonal variation
Av <- 1.0                                             # Seasonal variation adjustment, Av<-1.0 when lat < 54N
Mf <- dtt/6 * ((Sv * Av * (MFMAX - MFMIN)) + MFMIN)   # Seasonally varying non-rain melt factor
# New snow temperature and heat deficit from new snow
if(Ta < 0) T_snow_new <- Ta else T_snow_new <- 0
# Change in the heat deficit due to new snowfall [mm], 80 cal/g:
#latent heat of fusion, 0.5 cal/g/C: specific heat of ice
delta_HD_snow <- -(T_snow_new * Pn)/(80/0.5)
# Heat Exchange due to a temperature gradient
# change in heat deficit due to a temperature gradient [mm]
delta_HD_T <- NMF * dtp/6 * Mf/MFMAX * (ATI - T_snow_new)
# Update ATI[Antecedent Temperature Index]
if(Pn > (1.5*dtp)) {
ATI <- T_snow_new       #Antecedent temperature index
} else {
TIPM_dtt <- 1.0 - ((1.0 - TIPM)^(dtt/6))
ATI <- ATI + TIPM_dtt * (Ta - ATI)
}
ATI <- min(ATI,0)
# SNOW MELT
T_rain  <- max(Ta,0)    # Temperature of rain (deg C), Ta or 0C, whichever greater
if(RAIN > (0.25 * dtp)) {
# Rain-on-Snow Melt
stefan <- 6.12*(10^(-10))                                               # Stefan-Boltzman constant (mm/K/hr)
e_sat  <- 2.7489*(10^8)*exp((-4278.63/(Ta+242.792)))                    # Saturated vapor pressure at Ta (mb)
P_atm  <- 33.86*(29.9-(0.335*(elev/100))+(0.00022*((elev/100)^2.4)))    # Atmospheric pressure (mb) where elevation is in HUNDREDS of meters (this is incorrectly stated in the manual)
term1  <- stefan * dtp * (((Ta+273)^4)-(273^4))
term2  <- 0.0125 * RAIN * T_rain
term3  <- 8.5 * UADJ * (dtp/6) * ((0.9*e_sat - 6.11) + (0.00057*P_atm*Ta))
Melt   <- term1 + term2 + term3
Melt   <- max(Melt,0)
} else if (RAIN <= (0.25 * dtp) && (Ta > MBASE)) {
# Non-Rain Melt
Melt <- (Mf * (Ta - MBASE) * (dtp/dtt)) + (0.0125 * RAIN * T_rain)
Melt <- max(Melt,0)
} else {Melt <- 0}
# Ripeness of the snow cover
# W_i : water equivalent of the ice portion of the snow cover
# W_q : liquide water held by the snow
# W_qx: liquid water storage capacity
# Qw  : Amount of available water due to melt and rain
Deficit <- max(Deficit + delta_HD_snow + delta_HD_T, 0)    # Deficit <- heat deficit [mm]
if(Deficit > (0.33*W_i)) {
# limits of heat deficit
Deficit <- 0.33 * W_i
}
if (Melt < W_i) {
W_i  <- W_i-Melt
Qw   <- Melt + RAIN
W_qx <- PLWHC * W_i
}
if((Qw + W_q) > (Deficit + Deficit*PLWHC + W_qx)) { # THEN the snow is RIPE
E   <- Qw + W_q - W_qx - Deficit - (Deficit * PLWHC)       # Excess liquid water [mm]
W_i <- W_i + Deficit                             # W_i increases because water refreezes as heat deficit is decreased
W_q <- W_qx + PLWHC * Deficit                    # fills liquid water capacity
Deficit <- 0
} else if((Qw + W_q) >= Deficit) { #& [[Qw + W_q] <= [[Deficit*[1+PLWHC]] + W_qx]]
# THEN the snow is NOT yet ripe, but ice is being melted
E <- 0
W_i <- W_i + Deficit                # W_i increases because water refreezes as heat deficit is decreased
W_q <- W_q + Qw - Deficit
Deficit <- 0
} else if((Qw + W_q) < Deficit) {      #elseif [[Qw + W_q] < Deficit]
# THEN the snow is NOT yet ripe
E <- 0
W_i <- W_i + Qw + W_q                    # W_i increases because water refreezes as heat deficit is decreased
Deficit <- Deficit - Qw - W_q
}
else  {
Melt <- W_i+W_q # Melt >= W_i
W_i <- 0
W_q <- 0
Qw <- Melt + RAIN
E  <- Qw
#         SWE = 0
}
if(Deficit == 0) {ATI = 0}
# Constant daily amount of melt which takes place at the snow-soil
# interface whenever there is a snow cover
if (W_i > DAYGM) {
gmwlos <- (DAYGM/W_i)*W_q
gmslos <- DAYGM
gmro <- gmwlos + gmslos
W_i <- W_i - gmslos
W_q <- W_q - gmwlos
E <- E + gmro
SWE <- W_i + W_q
} else {
gmro <- W_i + W_q
W_i <- 0
W_q <- 0
E <- E + gmro
SWE <- 0
}
meltNrain <- E
states_input_update <- c(W_i ,ATI ,W_q ,Deficit)
return(list(SWE, meltNrain, state_input_update))
}
#SNOW MODULE
snow17 <- function(pars, prcp, temp, elev, states_input, TIME) {
#State parameters
W_i     <- states_input[1]; ATI <- states_input[2]
W_q     <- states_input[3]; Deficit <- states_input[4]
#Other parameters
SCF    <- pars[1]; PXTEMP <- pars[2]; MFMAX <- pars[3]; MFMIN <- pars[4]
UADJ   <- pars[5]; MBASE  <- pars[6]; TIPM  <- pars[7]; PLWHC  <- pars[8]
NMF    <- pars[9]; DAYGM  <- pars[10]
dtt <- 24  # time interval of temperature data
dtp <- 24  # time interval of prcipitation data
Ta <- temp  # Air temperature at this time step [deg C]
Pr <- prcp  # Precipitation at this time step [mm]
# FORM OF PRECIPITATION
if (Ta <= PXTEMP) {
# Air temperature is cold enough for snow to occur
SNOW <- Pr
RAIN <- 0
} else {
# Air temperature is warm enough for rain
SNOW <- 0
RAIN <- Pr
}
# ACCUMULATION OF THE SNOW COVER
Pn  <- SNOW * SCF  # Water equivalent of new snowfall [mm]
W_i <- W_i + Pn    # Water equivalent of the ice portion of the snow cover [mm]
E   <- 0           # Excess liquid water in the snow cover
# ENERGY EXCHANGE AT SNOW/AIR SURFACE DURING NON-MELT PERIODS
# Seasonal variation in the non-rain melt factor
DAYN <- TIME[2]
end_doy <- yday(as.Date(paste0(year(test),"/12/31"))) - 365
N_Mar21 <- DAYN - (80 + end_doy)
Sv <- (0.5*sin((N_Mar21 * 2 * pi)/days)) + 0.5        # Seasonal variation
Av <- 1.0                                             # Seasonal variation adjustment, Av<-1.0 when lat < 54N
Mf <- dtt/6 * ((Sv * Av * (MFMAX - MFMIN)) + MFMIN)   # Seasonally varying non-rain melt factor
# New snow temperature and heat deficit from new snow
if(Ta < 0) T_snow_new <- Ta else T_snow_new <- 0
# Change in the heat deficit due to new snowfall [mm], 80 cal/g:
#latent heat of fusion, 0.5 cal/g/C: specific heat of ice
delta_HD_snow <- -(T_snow_new * Pn)/(80/0.5)
# Heat Exchange due to a temperature gradient
# change in heat deficit due to a temperature gradient [mm]
delta_HD_T <- NMF * dtp/6 * Mf/MFMAX * (ATI - T_snow_new)
# Update ATI[Antecedent Temperature Index]
if(Pn > (1.5*dtp)) {
ATI <- T_snow_new       #Antecedent temperature index
} else {
TIPM_dtt <- 1.0 - ((1.0 - TIPM)^(dtt/6))
ATI <- ATI + TIPM_dtt * (Ta - ATI)
}
ATI <- min(ATI,0)
# SNOW MELT
T_rain  <- max(Ta,0)    # Temperature of rain (deg C), Ta or 0C, whichever greater
if(RAIN > (0.25 * dtp)) {
# Rain-on-Snow Melt
stefan <- 6.12*(10^(-10))                                               # Stefan-Boltzman constant (mm/K/hr)
e_sat  <- 2.7489*(10^8)*exp((-4278.63/(Ta+242.792)))                    # Saturated vapor pressure at Ta (mb)
P_atm  <- 33.86*(29.9-(0.335*(elev/100))+(0.00022*((elev/100)^2.4)))    # Atmospheric pressure (mb) where elevation is in HUNDREDS of meters (this is incorrectly stated in the manual)
term1  <- stefan * dtp * (((Ta+273)^4)-(273^4))
term2  <- 0.0125 * RAIN * T_rain
term3  <- 8.5 * UADJ * (dtp/6) * ((0.9*e_sat - 6.11) + (0.00057*P_atm*Ta))
Melt   <- term1 + term2 + term3
Melt   <- max(Melt,0)
} else if (RAIN <= (0.25 * dtp) && (Ta > MBASE)) {
# Non-Rain Melt
Melt <- (Mf * (Ta - MBASE) * (dtp/dtt)) + (0.0125 * RAIN * T_rain)
Melt <- max(Melt,0)
} else {Melt <- 0}
# Ripeness of the snow cover
# W_i : water equivalent of the ice portion of the snow cover
# W_q : liquide water held by the snow
# W_qx: liquid water storage capacity
# Qw  : Amount of available water due to melt and rain
Deficit <- max(Deficit + delta_HD_snow + delta_HD_T, 0)    # Deficit <- heat deficit [mm]
if(Deficit > (0.33*W_i)) {
# limits of heat deficit
Deficit <- 0.33 * W_i
}
if (Melt < W_i) {
W_i  <- W_i-Melt
Qw   <- Melt + RAIN
W_qx <- PLWHC * W_i
}
if((Qw + W_q) > (Deficit + Deficit*PLWHC + W_qx)) { # THEN the snow is RIPE
E   <- Qw + W_q - W_qx - Deficit - (Deficit * PLWHC)       # Excess liquid water [mm]
W_i <- W_i + Deficit                             # W_i increases because water refreezes as heat deficit is decreased
W_q <- W_qx + PLWHC * Deficit                    # fills liquid water capacity
Deficit <- 0
} else if((Qw + W_q) >= Deficit) { #& [[Qw + W_q] <= [[Deficit*[1+PLWHC]] + W_qx]]
# THEN the snow is NOT yet ripe, but ice is being melted
E <- 0
W_i <- W_i + Deficit                # W_i increases because water refreezes as heat deficit is decreased
W_q <- W_q + Qw - Deficit
Deficit <- 0
} else if((Qw + W_q) < Deficit) {      #elseif [[Qw + W_q] < Deficit]
# THEN the snow is NOT yet ripe
E <- 0
W_i <- W_i + Qw + W_q                    # W_i increases because water refreezes as heat deficit is decreased
Deficit <- Deficit - Qw - W_q
}
else  {
Melt <- W_i+W_q # Melt >= W_i
W_i <- 0
W_q <- 0
Qw <- Melt + RAIN
E  <- Qw
#         SWE = 0
}
if(Deficit == 0) {ATI = 0}
# Constant daily amount of melt which takes place at the snow-soil
# interface whenever there is a snow cover
if (W_i > DAYGM) {
gmwlos <- (DAYGM/W_i)*W_q
gmslos <- DAYGM
gmro <- gmwlos + gmslos
W_i <- W_i - gmslos
W_q <- W_q - gmwlos
E <- E + gmro
SWE <- W_i + W_q
} else {
gmro <- W_i + W_q
W_i <- 0
W_q <- 0
E <- E + gmro
SWE <- 0
}
meltNrain <- E
states_input_update <- c(W_i ,ATI ,W_q ,Deficit)
return(list(SWE, meltNrain, state_input_update))
}
dpath  <- "./_Data/raw/St Croix/"
dpath
# All xlsx files in the folder
dpath  <- "./_Data/raw/St Croix/"
dxlsx  <- list.files(path = dpath, pattern=".xlsx")
dxlsx2 <- dxlsx[which(substr(dxlsx,1,1) == "Q")]
dxlsx2
dxlsx
dpath  <- "./data/raw/St Croix/"
dxlsx  <- list.files(path = dpath, pattern=".xlsx")
dxlsx
dpath
# All xlsx files in the folder
dpath  <- "./data/raw/St Croix/"
dxlsx  <- list.files(path = dpath, pattern=".xlsx")
dxlsx2 <- dxlsx[which(substr(dxlsx,1,1) == "Q")]
dxlsx
source("./00_initial.R")
cfs_to_cms <- 28316.8 / 10^6
### Streamflow data ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
# All xlsx files in the folder
dpath  <- "./data/raw/"
dxlsx  <- list.files(path = dpath, pattern=".xlsx")
dxlsx2 <- dxlsx[which(substr(dxlsx,1,1) == "Q")]
source("./00_initial.R")
cfs_to_cms <- 28316.8 / 10^6
### Streamflow data ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
# All xlsx files in the folder
dpath  <- "./data/raw/"
dxlsx  <- list.files(path = dpath, pattern=".xlsx")
dxlsx2 <- dxlsx[which(substr(dxlsx,1,1) == "Q")]
All xlsx files in the folder
dpath  <- "./data/streamflow/"
dxlsx  <- list.files(path = dpath, pattern=".xlsx")
dxlsx2 <- dxlsx[which(substr(dxlsx,1,1) == "Q")]
dpath  <- "./data/streamflow/"
dxlsx  <- list.files(path = dpath, pattern=".xlsx")
dxlsx
# MODEL SETTINGS ---------------------------------------------------------------
source("./R/sac_sma.R")
source("./R/sac_sma_dsm.R")
source("./R/PET functions.R")
source("./R/route_lohamann.R")
# Main file directory
main_filedir <- "C:/Users/Umit/Google Drive/Research/Projects/_DEV/sac_sma_test/"
# Directory containing HRU files
hru_filedir <- paste0(main_filedir,"HRU_climfiles_SACSMA/")
# GridInfo file location
hru_infodir <- paste0(main_filedir,"HRUfiles/")
#Grid information file, each row = a unique hru, each column  = a feature
gridinfo <- read.table(paste0(hru_infodir, 'HRUinfo_arrhon.txt'))
#Calibrated sac-sma parameters
calib_par <- read.table(paste0(hru_infodir,'hru_optpar_0425_arrhon_KGE75.txt'))
str_date = as.Date("1995/10/1")
end_date = as.Date("2014/09/30")
grid_lat = gridinfo[[1]]
grid_lon = gridinfo[[2]]
grid_area = gridinfo[[3]]
grid_elev = gridinfo[[4]]
grid_flowlen = gridinfo[[5]]
grid_par  = calib_par
flag_SNOW17 = 0
#Essential R-packages needed
require(tidyr)
require(dplyr)
require(readr)
require(lubridate)
# Initial Storage States in SAC_SMA
uztwc <- 0  # Upper zone tension water storage
uzfwc <- 0  # Upper zone free water storage
lztwc <- 5  # Lower zone tension water storage
lzfsc <- 5  # Lower zone supplementary free water storage
lzfpc <- 5  # Upper zone primary free water storage
adimc <- 0  # Additional impervious area storage
inistates <- c(uztwc, uzfwc, lztwc, lzfsc, lzfpc, adimc)
# Include states for snow17 if snow module is 'on'
if (flag_SNOW17 == 1) {
W_i     <- 0  # Accumulated water equivalent of the ice portion of the snow cover (mm)
ATI     <- 0  # Antecedent Temperature Index, deg C
W_q     <- 0  # Liquid water held by the snow (mm)
Deficit <- 0  # Heat Deficit, also known as NEGHS, Negative Heat Storage
inistates <- c(inistates, W_i, ATI, W_q, Deficit)
}
# Base Time of Unit Hydrographs of HRU and River in Routing model.
# (Necessary to be changed only for a VERY LARGE watershed)
KE      <-  12  # Base time for HRU UH (day)
UH_DAY  <-  96  # Base time for river routing UH (day)
#Essential R-packages needed
require(tidyr)
require(dplyr)
require(readr)
require(lubridate)
# Initial Storage States in SAC_SMA
uztwc <- 0  # Upper zone tension water storage
uzfwc <- 0  # Upper zone free water storage
lztwc <- 5  # Lower zone tension water storage
lzfsc <- 5  # Lower zone supplementary free water storage
lzfpc <- 5  # Upper zone primary free water storage
adimc <- 0  # Additional impervious area storage
inistates <- c(uztwc, uzfwc, lztwc, lzfsc, lzfpc, adimc)
# Include states for snow17 if snow module is 'on'
if (flag_SNOW17 == 1) {
W_i     <- 0  # Accumulated water equivalent of the ice portion of the snow cover (mm)
ATI     <- 0  # Antecedent Temperature Index, deg C
W_q     <- 0  # Liquid water held by the snow (mm)
Deficit <- 0  # Heat Deficit, also known as NEGHS, Negative Heat Storage
inistates <- c(inistates, W_i, ATI, W_q, Deficit)
}
# Base Time of Unit Hydrographs of HRU and River in Routing model.
# (Necessary to be changed only for a VERY LARGE watershed)
KE      <-  12  # Base time for HRU UH (day)
UH_DAY  <-  96  # Base time for river routing UH (day)
# Run Distributed System Modeling version of SAC_SMA for each HRU
sim_date <- seq.Date(str_date, end_date, by = "day")
sim_per  <- length(sim_date)      # Simulation period
num_hru  <- nrow(gridinfo)        # Total number of HRUs
tot_area <- sum(grid_area)        # Total watershed area
#TOTFLOW <- matrix(0, nrow = sim_per, ncol = num_hru)
grid_lat <- sapply(1:num_hru, function(n)
formatC(grid_lat[n], format = 'f', flag='0', digits = 4))
# Run Distributed System Modeling version of SAC_SMA for each HRU
sim_date <- seq.Date(str_date, end_date, by = "day")
sim_per  <- length(sim_date)      # Simulation period
num_hru  <- nrow(gridinfo)        # Total number of HRUs
tot_area <- sum(grid_area)        # Total watershed area
#TOTFLOW <- matrix(0, nrow = sim_per, ncol = num_hru)
grid_lat <- sapply(1:num_hru, function(n)
formatC(grid_lat[n], format = 'f', flag='0', digits = 4))
# Run Distributed System Modeling version of SAC_SMA for each HRU
sim_date <- seq.Date(str_date, end_date, by = "day")
sim_per  <- length(sim_date)      # Simulation period
num_hru  <- nrow(gridinfo)        # Total number of HRUs
tot_area <- sum(grid_area)        # Total watershed area
#TOTFLOW <- matrix(0, nrow = sim_per, ncol = num_hru)
grid_lat <- sapply(1:num_hru, function(n)
formatC(grid_lat[n], format = 'f', flag='0', digits = 4))
#Lat-long information
grid_lat <- sapply(1:num_hru, function(n)
formatC(grid_lat[n], format = 'f', flag='0', digits = 4))
grid_lon <- sapply(1:num_hru, function(n)
formatC(grid_lat[n], format = 'f', flag='0', digits = 4))
grid_lat
grid_lon
n<-1
# Read-in data for current HRU
griddata  <- read.table(paste0(hru_filedir,hru_lat, "_", hru_lon))
# Read-in data for current HRU
griddata  <- read.table(paste0(hru_filedir,grid_lat[n], "_", grid_lon[n]))
# Read-in data for current HRU
griddata  <- read.table(paste0(hru_filedir,grid_lat[n], "_", grid_lon[n]))
